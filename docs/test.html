<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>VibeMatch.test API documentation</title>
<meta name="description" content="This file is responsible for testing the code to ensure some semblance of reliable functionality.
This should be run anytime functionality is changed, â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>VibeMatch.test</code></h1>
</header>
<section id="section-intro">
<p>This file is responsible for testing the code to ensure some semblance of reliable functionality.
This should be run anytime functionality is changed, and should be expanded upon when functionality is added
This file is run in CI/actions on pushes to the main branch</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This file is responsible for testing the code to ensure some semblance of reliable functionality.
This should be run anytime functionality is changed, and should be expanded upon when functionality is added
This file is run in CI/actions on pushes to the main branch
&#34;&#34;&#34;


import os
import sys
import pytest
import importlib
from utilities import Logger, LogLevel


def import_lib(lib, explode=False):
    &#34;&#34;&#34;
    Tries to import a library.
    If that doesn&#39;t work, it will return the exception as a string
    Args:
        lib: (string) the library name to import
        explode: (bool) whether or not to raise an exception

    Returns:
        the module, or an exception message
    &#34;&#34;&#34;
    try:
        return importlib.import_module(lib.strip())
    except Exception as import_exception:
        if explode:
            raise import_exception
        else:
            return f&#34;{import_exception}&#34;


def import_libs(libs):
    &#34;&#34;&#34;
    Imports a list of libraries to ensure they can be loaded
    Args:
        libs: (list) containing strings corresponding to modules to import
    &#34;&#34;&#34;
    error_libs = []
    for lib in libs:
        imported = import_lib(lib)
        if isinstance(imported, str):  # failed to load, this is an exception string
            error_libs.append(imported)
    if len(error_libs):
        raise ImportError(f&#34;Unable to import the following libraries: {&#39;,&#39;.join(error_libs)}. &#34; +
                          &#34;Please run &#39;pip install -r requirements.txt&#39;&#34;)


def import_libs_with_paths(lib_list):
    &#34;&#34;&#34;
    Imports a list of libraries to ensure they can be loaded
    Mentions the file path the import came from if the import fails
    Args:
        lib_list: (list of tuples containing two strings)
    &#34;&#34;&#34;
    error_libs = []
    for lib, path in lib_list.items():
        imported = import_lib(lib)
        if isinstance(imported, str):  # failed to load, this is an exception string
            error_libs.append((lib, path, imported))
    if len(error_libs):
        errs = [f&#34;Cannot import &#39;{lib}&#39; in {path} because: {err}&#34; for lib, path, err in error_libs]
        err_str = &#39;\n&#39;.join(errs)
        import_str = &#39;,&#39;.join([lib for lib, _, _ in error_libs])
        raise ImportError(f&#34;Unable to import the following libraries: {err_str}. Please run &#39;pip install {import_str}&#39;&#34;)


def get_required_libs():
    &#34;&#34;&#34;
    Gets the list of required libs from requirements.txt
    Returns:
        (list) list of strings
    &#34;&#34;&#34;
    with open(&#34;requirements.txt&#34;, &#39;r&#39;) as reqs:
        libs = reqs.readlines()
    for i in range(len(libs)):
        libs[i] = libs[i].strip(&#39;\n \t&#39;)
        if libs[i] == &#34;pdoc3&#34;:  # special handling for this one which uses a different name on import
            libs[i] = &#34;pdoc&#34;
    return libs


def test_anything_works():
    &#34;&#34;&#34;
    Asserts that tests are working
    &#34;&#34;&#34;
    assert 2 == 2, &#34;2 does not equal 2!?&#34;
    with pytest.raises(Exception):
        assert 2 == 3, &#34;2 equals 3!?&#34;


def test_libs():
    &#34;&#34;&#34;
    Imports the libraries included in the requirements file to ensure they can all be used
    &#34;&#34;&#34;
    libs = get_required_libs()
    try:
        import_libs(libs)
    except ImportError as import_error:
        Logger.write(f&#34;{import_error}&#34;, LogLevel.Error)
        try:
            import subprocess
            subprocess.check_call(&#34;pip install -r requirements.txt&#34;.split(&#39; &#39;))
        except Exception:
            raise Exception(f&#34;Unable to import libraries, and unable to run pip install automatically: {import_error}&#34;)


def test_missing_libs():
    &#34;&#34;&#34;
    Checks for libraries used that are missing from requirements.txt, also tries to import them to ensure they exist
    &#34;&#34;&#34;
    libs = dict()
    for root, dirs, files in os.walk(&#34;.&#34;):  # recursively traverses the current directory
        for file in files:  # the list of files for each respective directory
            if file.endswith(&#34;.py&#34;):
                path_name = os.path.join(root, file)  # create the full path to use and print
                with open(path_name, &#39;r&#39;) as py_file:
                    txt = py_file.readlines()  # read all lines into a list
                    for line in txt:
                        if line.startswith(&#34;import &#34;):
                            lib_to_import = line[line.find(&#34;import &#34;)+7:].strip(&#34;\n \t&#34;)  # grab the library that&#39;s imported
                            libs[lib_to_import] = path_name
    import_libs_with_paths(libs)


def test_db_connection():
    &#34;&#34;&#34;
    Test some basic database interaction
    &#34;&#34;&#34;
    import spotify
    from database import create_features_table, get_audio_features
    assert create_features_table()
    spotify.get_audio_features(&#34;651YhrvzeVfOa8yIifIhUM&#34;)
    assert get_audio_features(1)


def test_spotify():
    &#34;&#34;&#34;
    Test some basic spotify api interaction
    &#34;&#34;&#34;
    from spotify import find_song, get_audio_features
    find_song(song_name=&#34;Come With Me&#34;, artist=&#34;Will Sparks&#34;)
    get_audio_features(&#34;651YhrvzeVfOa8yIifIhUM&#34;)


def test_spotify_download():
    &#34;&#34;&#34;
    Tests some basic downloading functionality
    &#34;&#34;&#34;
    from spotify import download_songs
    import subprocess
    if os.path.exists(&#34;songs/Hardwell - I FEEL LIKE DANCING.mp3&#34;):  # already verified this functionality works
        os.remove(&#34;songs/Hardwell - I FEEL LIKE DANCING.mp3&#34;)
        Logger.write(&#34;Removed existing test song, will download on next run&#34;)
        return
    try:
        subprocess.check_call(&#34;ffmpeg&#34;)
    except FileNotFoundError as no_ffmpeg_error:
        import platform
        Logger.write(&#34;Ffmpeg is not installed! Cannot download songs. Please install ffpmeg and try again&#34;)
        Logger.write(&#34;Ffmpeg can be download from https://ffmpeg.org/download.html, or using a package manager such as &#39;apt-get install ffmpeg&#39;&#34;)
        system = platform.system().lower()
        if system == &#34;windows&#34;:
            Logger.write(&#34;Download it from here https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-essentials.7z&#34;)
        elif &#34;mac os x&#34; in system:
            Logger.write(&#34;Run curl -JL https://evermeet.cx/ffmpeg/getrelease/ffmpeg/7z --output ffmpeg.7z &amp;&amp; 7z -xfv ffmpeg.7z&#34;)
        elif &#34;nix&#34; in system:
            Logger.write(&#34;Run curl -JL https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-amd64-static.tar.xz --output ffmpeg.tar.xz &amp;&amp; 7z -xfv ffmpeg.tar.xz&#34;)
        return
    download_songs(&#34;651YhrvzeVfOa8yIifIhUM&#34;)
    assert os.path.exists(&#34;songs/Hardwell - I FEEL LIKE DANCING.mp3&#34;), &#34;Song wasn&#39;t downloaded&#34;


def test_note_conversion():
    &#34;&#34;&#34;
    Tests converting notes
    &#34;&#34;&#34;
    from utilities import Notes
    assert Notes.from_string(&#34;Cflat&#34;) == 11
    assert Notes.from_int(Notes.Gflat) == &#34;Fsharp&#34;
    assert Notes.from_string(&#34;gsharp&#34;) == 8


def test_matching():
    &#34;&#34;&#34;
    Tests some basic matching functionality
    &#34;&#34;&#34;
    import spotify
    import match
    f1 = spotify.get_audio_features(spotify.find_song(song_name=&#34;Come With Me&#34;, artist=&#34;Will Sparks&#34;)[0].get(&#34;id&#34;))
    f2 = spotify.get_audio_features(&#34;651YhrvzeVfOa8yIifIhUM&#34;)
    key1 = f1.get(&#34;key&#34;)
    key2 = f2.get(&#34;key&#34;)
    d1 = f1.get(&#34;danceability&#34;)
    d2 = f2.get(&#34;danceability&#34;)
    assert not match.keys_match(key1, key2, 1)
    assert match.danceability_match(d1, d2, 1)
    assert match.good_for_mixing(f1, f2)
    assert match.vibes_match(f1, f2)


if __name__ == &#34;__main__&#34;:  # main entry point
    args = sys.argv[1:]
    if len(args):  # if there are any command line args
        for arg in args:  # check all command line parameters after the file name
            if arg in locals():  # checks if the parameter is a function in the current file
                locals()[arg]()  # runs the function
    else:
        # get all functions that start with &#39;test_&#39; i.e. is a pytest function
        test_funcs = [local for local in locals().copy() if local.startswith(&#34;test_&#34;)]
        total = len(test_funcs)
        passed = 0
        failed = []
        for test in test_funcs:  # for every local attribute of this file that seems to be a test function
            Logger.set_log_level(LogLevel.Error)
            try:
                locals()[test]()  # run the function
                Logger.set_log_level(LogLevel.Info)
                Logger.write(f&#34;Test &#39;{test}&#39; passed&#34;)
                passed += 1
            except Exception as test_error:
                Logger.set_log_level(LogLevel.Info)
                fail_msg = f&#34;Test &#39;{test}&#39; failed due to error: {test_error}&#34;
                Logger.write(fail_msg)
                failed.append(test)
        Logger.write(f&#34;{passed} of {total} ({(passed/total)*100:.2f}%) tests passed&#34;)
        if len(failed):  # any failed tests exist
            Logger.write(f&#34;Failing tests: {failed}&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="VibeMatch.test.get_required_libs"><code class="name flex">
<span>def <span class="ident">get_required_libs</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the list of required libs from requirements.txt</p>
<h2 id="returns">Returns</h2>
<p>(list) list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_required_libs():
    &#34;&#34;&#34;
    Gets the list of required libs from requirements.txt
    Returns:
        (list) list of strings
    &#34;&#34;&#34;
    with open(&#34;requirements.txt&#34;, &#39;r&#39;) as reqs:
        libs = reqs.readlines()
    for i in range(len(libs)):
        libs[i] = libs[i].strip(&#39;\n \t&#39;)
        if libs[i] == &#34;pdoc3&#34;:  # special handling for this one which uses a different name on import
            libs[i] = &#34;pdoc&#34;
    return libs</code></pre>
</details>
</dd>
<dt id="VibeMatch.test.import_lib"><code class="name flex">
<span>def <span class="ident">import_lib</span></span>(<span>lib, explode=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Tries to import a library.
If that doesn't work, it will return the exception as a string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lib</code></strong></dt>
<dd>(string) the library name to import</dd>
<dt><strong><code>explode</code></strong></dt>
<dd>(bool) whether or not to raise an exception</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the module, or an exception message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_lib(lib, explode=False):
    &#34;&#34;&#34;
    Tries to import a library.
    If that doesn&#39;t work, it will return the exception as a string
    Args:
        lib: (string) the library name to import
        explode: (bool) whether or not to raise an exception

    Returns:
        the module, or an exception message
    &#34;&#34;&#34;
    try:
        return importlib.import_module(lib.strip())
    except Exception as import_exception:
        if explode:
            raise import_exception
        else:
            return f&#34;{import_exception}&#34;</code></pre>
</details>
</dd>
<dt id="VibeMatch.test.import_libs"><code class="name flex">
<span>def <span class="ident">import_libs</span></span>(<span>libs)</span>
</code></dt>
<dd>
<div class="desc"><p>Imports a list of libraries to ensure they can be loaded</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>libs</code></strong></dt>
<dd>(list) containing strings corresponding to modules to import</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_libs(libs):
    &#34;&#34;&#34;
    Imports a list of libraries to ensure they can be loaded
    Args:
        libs: (list) containing strings corresponding to modules to import
    &#34;&#34;&#34;
    error_libs = []
    for lib in libs:
        imported = import_lib(lib)
        if isinstance(imported, str):  # failed to load, this is an exception string
            error_libs.append(imported)
    if len(error_libs):
        raise ImportError(f&#34;Unable to import the following libraries: {&#39;,&#39;.join(error_libs)}. &#34; +
                          &#34;Please run &#39;pip install -r requirements.txt&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="VibeMatch.test.import_libs_with_paths"><code class="name flex">
<span>def <span class="ident">import_libs_with_paths</span></span>(<span>lib_list)</span>
</code></dt>
<dd>
<div class="desc"><p>Imports a list of libraries to ensure they can be loaded
Mentions the file path the import came from if the import fails</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lib_list</code></strong></dt>
<dd>(list of tuples containing two strings)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_libs_with_paths(lib_list):
    &#34;&#34;&#34;
    Imports a list of libraries to ensure they can be loaded
    Mentions the file path the import came from if the import fails
    Args:
        lib_list: (list of tuples containing two strings)
    &#34;&#34;&#34;
    error_libs = []
    for lib, path in lib_list.items():
        imported = import_lib(lib)
        if isinstance(imported, str):  # failed to load, this is an exception string
            error_libs.append((lib, path, imported))
    if len(error_libs):
        errs = [f&#34;Cannot import &#39;{lib}&#39; in {path} because: {err}&#34; for lib, path, err in error_libs]
        err_str = &#39;\n&#39;.join(errs)
        import_str = &#39;,&#39;.join([lib for lib, _, _ in error_libs])
        raise ImportError(f&#34;Unable to import the following libraries: {err_str}. Please run &#39;pip install {import_str}&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="VibeMatch.test.test_anything_works"><code class="name flex">
<span>def <span class="ident">test_anything_works</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Asserts that tests are working</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_anything_works():
    &#34;&#34;&#34;
    Asserts that tests are working
    &#34;&#34;&#34;
    assert 2 == 2, &#34;2 does not equal 2!?&#34;
    with pytest.raises(Exception):
        assert 2 == 3, &#34;2 equals 3!?&#34;</code></pre>
</details>
</dd>
<dt id="VibeMatch.test.test_db_connection"><code class="name flex">
<span>def <span class="ident">test_db_connection</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Test some basic database interaction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_db_connection():
    &#34;&#34;&#34;
    Test some basic database interaction
    &#34;&#34;&#34;
    import spotify
    from database import create_features_table, get_audio_features
    assert create_features_table()
    spotify.get_audio_features(&#34;651YhrvzeVfOa8yIifIhUM&#34;)
    assert get_audio_features(1)</code></pre>
</details>
</dd>
<dt id="VibeMatch.test.test_libs"><code class="name flex">
<span>def <span class="ident">test_libs</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Imports the libraries included in the requirements file to ensure they can all be used</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_libs():
    &#34;&#34;&#34;
    Imports the libraries included in the requirements file to ensure they can all be used
    &#34;&#34;&#34;
    libs = get_required_libs()
    try:
        import_libs(libs)
    except ImportError as import_error:
        Logger.write(f&#34;{import_error}&#34;, LogLevel.Error)
        try:
            import subprocess
            subprocess.check_call(&#34;pip install -r requirements.txt&#34;.split(&#39; &#39;))
        except Exception:
            raise Exception(f&#34;Unable to import libraries, and unable to run pip install automatically: {import_error}&#34;)</code></pre>
</details>
</dd>
<dt id="VibeMatch.test.test_matching"><code class="name flex">
<span>def <span class="ident">test_matching</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests some basic matching functionality</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_matching():
    &#34;&#34;&#34;
    Tests some basic matching functionality
    &#34;&#34;&#34;
    import spotify
    import match
    f1 = spotify.get_audio_features(spotify.find_song(song_name=&#34;Come With Me&#34;, artist=&#34;Will Sparks&#34;)[0].get(&#34;id&#34;))
    f2 = spotify.get_audio_features(&#34;651YhrvzeVfOa8yIifIhUM&#34;)
    key1 = f1.get(&#34;key&#34;)
    key2 = f2.get(&#34;key&#34;)
    d1 = f1.get(&#34;danceability&#34;)
    d2 = f2.get(&#34;danceability&#34;)
    assert not match.keys_match(key1, key2, 1)
    assert match.danceability_match(d1, d2, 1)
    assert match.good_for_mixing(f1, f2)
    assert match.vibes_match(f1, f2)</code></pre>
</details>
</dd>
<dt id="VibeMatch.test.test_missing_libs"><code class="name flex">
<span>def <span class="ident">test_missing_libs</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks for libraries used that are missing from requirements.txt, also tries to import them to ensure they exist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_missing_libs():
    &#34;&#34;&#34;
    Checks for libraries used that are missing from requirements.txt, also tries to import them to ensure they exist
    &#34;&#34;&#34;
    libs = dict()
    for root, dirs, files in os.walk(&#34;.&#34;):  # recursively traverses the current directory
        for file in files:  # the list of files for each respective directory
            if file.endswith(&#34;.py&#34;):
                path_name = os.path.join(root, file)  # create the full path to use and print
                with open(path_name, &#39;r&#39;) as py_file:
                    txt = py_file.readlines()  # read all lines into a list
                    for line in txt:
                        if line.startswith(&#34;import &#34;):
                            lib_to_import = line[line.find(&#34;import &#34;)+7:].strip(&#34;\n \t&#34;)  # grab the library that&#39;s imported
                            libs[lib_to_import] = path_name
    import_libs_with_paths(libs)</code></pre>
</details>
</dd>
<dt id="VibeMatch.test.test_note_conversion"><code class="name flex">
<span>def <span class="ident">test_note_conversion</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests converting notes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_note_conversion():
    &#34;&#34;&#34;
    Tests converting notes
    &#34;&#34;&#34;
    from utilities import Notes
    assert Notes.from_string(&#34;Cflat&#34;) == 11
    assert Notes.from_int(Notes.Gflat) == &#34;Fsharp&#34;
    assert Notes.from_string(&#34;gsharp&#34;) == 8</code></pre>
</details>
</dd>
<dt id="VibeMatch.test.test_spotify"><code class="name flex">
<span>def <span class="ident">test_spotify</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Test some basic spotify api interaction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_spotify():
    &#34;&#34;&#34;
    Test some basic spotify api interaction
    &#34;&#34;&#34;
    from spotify import find_song, get_audio_features
    find_song(song_name=&#34;Come With Me&#34;, artist=&#34;Will Sparks&#34;)
    get_audio_features(&#34;651YhrvzeVfOa8yIifIhUM&#34;)</code></pre>
</details>
</dd>
<dt id="VibeMatch.test.test_spotify_download"><code class="name flex">
<span>def <span class="ident">test_spotify_download</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests some basic downloading functionality</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_spotify_download():
    &#34;&#34;&#34;
    Tests some basic downloading functionality
    &#34;&#34;&#34;
    from spotify import download_songs
    import subprocess
    if os.path.exists(&#34;songs/Hardwell - I FEEL LIKE DANCING.mp3&#34;):  # already verified this functionality works
        os.remove(&#34;songs/Hardwell - I FEEL LIKE DANCING.mp3&#34;)
        Logger.write(&#34;Removed existing test song, will download on next run&#34;)
        return
    try:
        subprocess.check_call(&#34;ffmpeg&#34;)
    except FileNotFoundError as no_ffmpeg_error:
        import platform
        Logger.write(&#34;Ffmpeg is not installed! Cannot download songs. Please install ffpmeg and try again&#34;)
        Logger.write(&#34;Ffmpeg can be download from https://ffmpeg.org/download.html, or using a package manager such as &#39;apt-get install ffmpeg&#39;&#34;)
        system = platform.system().lower()
        if system == &#34;windows&#34;:
            Logger.write(&#34;Download it from here https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-essentials.7z&#34;)
        elif &#34;mac os x&#34; in system:
            Logger.write(&#34;Run curl -JL https://evermeet.cx/ffmpeg/getrelease/ffmpeg/7z --output ffmpeg.7z &amp;&amp; 7z -xfv ffmpeg.7z&#34;)
        elif &#34;nix&#34; in system:
            Logger.write(&#34;Run curl -JL https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-amd64-static.tar.xz --output ffmpeg.tar.xz &amp;&amp; 7z -xfv ffmpeg.tar.xz&#34;)
        return
    download_songs(&#34;651YhrvzeVfOa8yIifIhUM&#34;)
    assert os.path.exists(&#34;songs/Hardwell - I FEEL LIKE DANCING.mp3&#34;), &#34;Song wasn&#39;t downloaded&#34;</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="VibeMatch" href="index.html">VibeMatch</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="VibeMatch.test.get_required_libs" href="#VibeMatch.test.get_required_libs">get_required_libs</a></code></li>
<li><code><a title="VibeMatch.test.import_lib" href="#VibeMatch.test.import_lib">import_lib</a></code></li>
<li><code><a title="VibeMatch.test.import_libs" href="#VibeMatch.test.import_libs">import_libs</a></code></li>
<li><code><a title="VibeMatch.test.import_libs_with_paths" href="#VibeMatch.test.import_libs_with_paths">import_libs_with_paths</a></code></li>
<li><code><a title="VibeMatch.test.test_anything_works" href="#VibeMatch.test.test_anything_works">test_anything_works</a></code></li>
<li><code><a title="VibeMatch.test.test_db_connection" href="#VibeMatch.test.test_db_connection">test_db_connection</a></code></li>
<li><code><a title="VibeMatch.test.test_libs" href="#VibeMatch.test.test_libs">test_libs</a></code></li>
<li><code><a title="VibeMatch.test.test_matching" href="#VibeMatch.test.test_matching">test_matching</a></code></li>
<li><code><a title="VibeMatch.test.test_missing_libs" href="#VibeMatch.test.test_missing_libs">test_missing_libs</a></code></li>
<li><code><a title="VibeMatch.test.test_note_conversion" href="#VibeMatch.test.test_note_conversion">test_note_conversion</a></code></li>
<li><code><a title="VibeMatch.test.test_spotify" href="#VibeMatch.test.test_spotify">test_spotify</a></code></li>
<li><code><a title="VibeMatch.test.test_spotify_download" href="#VibeMatch.test.test_spotify_download">test_spotify_download</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>